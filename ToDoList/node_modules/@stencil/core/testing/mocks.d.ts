import type { BuildCtx, Cache, CompilerCtx, CompilerSystem, Config, Module } from '@stencil/core/internal';
import { TestingSystem } from './testing-sys';
import { TestingLogger } from './testing-logger';
export declare function mockConfig(sys?: CompilerSystem): Config;
export declare function mockCompilerCtx(config?: Config): CompilerCtx;
export declare function mockBuildCtx(config?: Config, compilerCtx?: CompilerCtx): BuildCtx;
export declare function mockCache(config?: Config, compilerCtx?: CompilerCtx): Cache;
export declare function mockLogger(): TestingLogger;
/**
 * Create a {@link CompilerSystem} entity for testing the compiler.
 *
 * This function acts as a thin wrapper around a {@link TestingSystem} entity creation. It exists to provide a logical
 * place in the codebase where we might expect Stencil engineers to reach for when attempting to mock a
 * {@link CompilerSystem} base type. Should there prove to be usage of both this function and the one it wraps,
 * reconsider if this wrapper is necessary.
 *
 * @returns a System instance for testing purposes.
 */
export declare function mockCompilerSystem(): TestingSystem;
export declare function mockDocument(html?: string): Document;
export declare function mockWindow(html?: string): Window;
/**
 * This gives you a mock Module, an interface which is the internal compiler
 * representation of a module. It includes a bunch of information necessary for
 * compilation, this mock basically sets sane defaults for all those values.
 *
 * @param mod is an override module that you can supply to set particular values
 * @returns a module object ready to use in tests!
 */
export declare const mockModule: (mod?: Partial<Module>) => Module;
